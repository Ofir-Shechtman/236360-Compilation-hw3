%{

   #include "semantics.hpp"
   #include "hw3_output.hpp"
   extern int yylineno;
   int yylex(void);
   int yyparse();
   void yyerror(const char*);

%}


%token VOID INT BYTE B BOOL TRUE FALSE RETURN WHILE BREAK CONTINUE SWITCH CASE ASSIGN DEFAULT COLON SC COMMA ID NUM STRING
%right IF
%right ELSE
%left LBRACE RBRACE
%left OR
%left AND
%left EQUALITY
%nonassoc RELOP
%left ADD_SUB_OP
%left MULT_DIV_OP
%right NOT
%left LPAREN RPAREN

%%

Program : {SymbolTable::GetInstance();} Funcs {SymbolTable::GetInstance()->print_funcs();}

Funcs : {}
        | FuncDecl Funcs

FuncDecl : RetType ID LPAREN Formals RPAREN LBRACE {SymbolTable::GetInstance()->push_ret($1);} Statements RBRACE {$$ = new Variable(new Func($1,$4),$2); SymbolTable::GetInstance()->add_Func($$); SymbolTable::GetInstance()->pop_ret();}

RetType : Type {$$=$1;}
        | VOID {$$=new Void();}

Formals : {$$ = new FormalsList();}
        | FormalsList {$$ = $1;}

FormalsList : FormalDecl {$$ = new FormalsList(); (dynamic_cast<FormalsList *>($$))->add($1);}
        | FormalDecl COMMA FormalsList {$$=$3;    (dynamic_cast<FormalsList *>($$))->add($1); }

FormalDecl : Type ID {$$= new Variable($1, $2);}

Statements : Statement {}
        | Statements Statement {}

Statement : LBRACE Scope RBRACE
        | Type ID SC {$$= new Variable($1, $2); SymbolTable::GetInstance()->add_var($$); }
        | Type ID ASSIGN Exp SC {$$= new Variable($1, $2); SymbolTable::GetInstance()->add_var($$); SymbolTable::GetInstance()->assign($2,$4);}
        | ID ASSIGN Exp SC {SymbolTable::GetInstance()->assign($1,$3);}
        | Call SC {}
        | RETURN SC {SymbolTable::GetInstance()->check_return(new Void());}
        | RETURN Exp SC {SymbolTable::GetInstance()->check_return($2);}
        | IfStatement %prec IF
        | IfStatement ELSE Scope %prec ELSE {}
        | WHILE LPAREN Exp {if(!Boolean::is_bool($3)) output::errorMismatch(yylineno);} RPAREN {SymbolTable::GetInstance()->push_while(new ReturnType("while"));} Statement {SymbolTable::GetInstance()->pop_while();} {}
        | BREAK SC {SymbolTable::GetInstance()->check_while(new ReturnType("break"));}
        | CONTINUE SC {SymbolTable::GetInstance()->check_while(new ReturnType("continue"));}
        | SWITCH LPAREN Exp RPAREN LBRACE {SymbolTable::GetInstance()->push();} CaseList {SymbolTable::GetInstance()->pop();} RBRACE {}

IfStatement : IF LPAREN Exp {if(!Boolean::is_bool($3)) output::errorMismatch(yylineno);} RPAREN Scope {}

Scope : {SymbolTable::GetInstance()->push();} Statements {SymbolTable::GetInstance()->pop();}

Call : ID LPAREN ExpList RPAREN {$$=SymbolTable::GetInstance()->call($1, $3);}
        | ID LPAREN RPAREN {$$=SymbolTable::GetInstance()->call($1);}

ExpList : Exp {$$ = new ExpList(); (dynamic_cast<ExpList *>($$))->add($1);}
        | Exp COMMA ExpList {$$=$3;    (dynamic_cast<ExpList *>($$))->add($1); }

Type : INT {$$=new Int();}
        | BYTE {$$=new Byte();}
        | BOOL {$$=new Bool();}

Exp : LPAREN Exp RPAREN {$$=$2;}
        | Exp MULT_DIV_OP Exp {}
        | Exp ADD_SUB_OP Exp {}
        | ID {}
        | Call {}
        | NUM {}
        | NUM B {$$=new NumB(dynamic_cast<Num *>($1)->val);}
        | STRING {}
        | TRUE {$$=new Boolean();}
        | FALSE {$$=new Boolean();}
        | NOT Exp {$$=new Boolean($1);}
        | Exp AND Exp {$$=new Boolean($1, $3);}
        | Exp OR Exp {$$=new Boolean($1, $3);}
        | Exp EQUALITY Exp {$$=new Boolean($1, $3);}
        | Exp RELOP Exp {$$=new Boolean($1, $3);}

CaseList : CaseDecl CaseList {}
        | CaseDecl {}
        | DEFAULT COLON Statements {}

CaseDecl : CASE NUM COLON Statements {}

%%


void yyerror(const char*){
    output::errorSyn(yylineno);
}



int main(){ return yyparse(); }
